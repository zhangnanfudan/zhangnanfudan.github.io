nu=.5 # 1 1.5
range=1
my.Matern=function(d1,d2){
Matern(abs(d1-d2), range=range, nu=nu)
}
my.cov=outer (d,d, my.Matern)
gp = mvrnorm(3, mu=rep(0, length(d)), Sigma = my.cov)
my.gp = data.frame(x=d,y=t(gp))
ggplot(my.gp, aes(x=x))+
geom_line(aes(y = y.1, colour = "y.1")) +
geom_line(aes(y = y.2, colour = "y.2")) +
geom_line(aes(y = y.3, colour = "y.3")) +
ylab('y') + ggtitle(paste("Matern(nu=", nu,")"))
dev.off()
grid<- list( x= seq( 0,10,length.out = 200), y= seq(0,10,length.out = 200))
obj1<-matern.image.cov( grid=grid, theta=.5, smoothness=.5, setup=TRUE)
look1<- sim.rf( obj1)
obj2<-matern.image.cov( grid=grid, theta=.5, smoothness=1, setup=TRUE)
look2<- sim.rf( obj2)
obj3<-matern.image.cov( grid=grid, theta=.5, smoothness=2, setup=TRUE)
look3<- sim.rf( obj3)
# take a look at first two
set.panel(1,3)
image.plot( grid$x, grid$y, look1)
title("Matern, nu=0.5")
image.plot( grid$x, grid$y, look2)
title("Matern, nu=1")
image.plot( grid$x, grid$y, look3)
title("Matern, nu=2 ")
nlon=length(unique(data[,1]))
nlat=length(unique(data[,2]))
loc=data[,1:2]
y=data[,3]
varigram=vgram(loc, y, lon.lat=TRUE,N=15)
par(mfrow=c(1,2))
##here obtained is semivarigram,then times 2 to get varigram##
##Plot the varigram cloud
plot(varigram$d,2*varigram$vgram,xlab="distance",ylab="varigram",main="Variogram cloud")
lines(varigram$centers, varigram$stats["mean",], col=4,lwd=3)
dim(data)
bplot.xy(varigram$d, sqrt(2*varigram$vgram),ylab="sqrt(VG)", N=15, outlier=TRUE, main="Boxplots of variogram")
lines(varigram$centers, sqrt(2*varigram$stats["mean",]), col=4,lwd=3)
graphics.off()
###directional variogram, fix the latitude.
data1=data[101:150,]
data2=data[201:250,]
data3=data[301:350,]
data4=data[401:450,]
vgram_lat1=vgram(data1[,1:2], data1[,3], lon.lat=TRUE, N=10)
vgram_lat2=vgram(data2[,1:2], data2[,3], lon.lat=TRUE, N=10)
vgram_lat3=vgram(data3[,1:2], data3[,3], lon.lat=TRUE, N=10)
vgram_lat4=vgram(data4[,1:2], data4[,3], lon.lat=TRUE, N=10)
# pdf('lat.pdf',width=14,height=14)
par(mfrow=c(2,2))
bplot.xy(vgram_lat1$d, sqrt(2*vgram_lat1$vgram),ylab="sqrt(VG)", N=10, outlier=TRUE, main="latitude -49.72")
lines(vgram_lat1$centers, sqrt(2*vgram_lat1$stats["mean",]), col=4, lwd=3)
bplot.xy(vgram_lat2$d, sqrt(2*vgram_lat2$vgram),ylab="sqrt(VG)", N=10, outlier=TRUE, main="latitude -9.94")
lines(vgram_lat2$centers, sqrt(2*vgram_lat2$stats["mean",]), col=4, lwd=3)
bplot.xy(vgram_lat3$d, sqrt(2*vgram_lat3$vgram),ylab="sqrt(VG)", N=10, outlier=TRUE, main="latitude 29.83")
lines(vgram_lat3$centers, sqrt(2*vgram_lat3$stats["mean",]), col=4, lwd=3)
bplot.xy(vgram_lat4$d, sqrt(2*vgram_lat4$vgram),ylab="sqrt(VG)", N=10, outlier=TRUE, main="latitude 69.61")
lines(vgram_lat4$centers, sqrt(2*vgram_lat4$stats["mean",]), col=4, lwd=3)
dev.off()
nan=c(60,
88,
63,
98,
61,
70,
30,
87,
71,
69,
41)
summary(nan)
library(MASS)
library(ggplot2)
library(fields)
y<- cbind(  Matern( d, nu=.5),
Matern( d, nu=1.0),
Matern( d, nu=2.0))
z<- cbind(  Matern( d, range=1),
Matern( d, range=2),
Matern( d, range=3))
set.panel(1,2)
matplot( d, y, type="l", lty=1, lwd=2, col=1:3, main='Matern with range 1')
set.panel(1,2)
matplot( d, y, type="l", lty=1, lwd=2, col=1:3, main='Matern with range 1')
legend('topright', legend=c('nu=0.5', 'nu=1', 'nu=2'), col=1:3, lty=1, lwd=2)
set.panel(1,2)
matplot( d, y, type="l", lty=1, lwd=2, col=1:3, main='Matern with range 1')
legend('topright', legend=c('nu=0.5', 'nu=1', 'nu=2'), col=1:3, lty=1, lwd=2)
matplot( d, z, type="l", lty=1, lwd=2, col=1:3, main='Matern with smoothness 0.5')
legend('topright', legend=c('range=1', 'range=2', 'range=3'), col=1:3, lty=1, lwd=2)
dev.off()
my.Matern=function(d1,d2){
Matern(abs(d1-d2), range=range, nu=nu)
}
my.cov=outer (d,d, my.Matern)
gp = mvrnorm(3, mu=rep(0, length(d)), Sigma = my.cov)
my.gp = data.frame(x=d,y=t(gp))
ggplot(my.gp, aes(x=x))+
geom_line(aes(y = y.1, colour = "y.1")) +
geom_line(aes(y = y.2, colour = "y.2")) +
geom_line(aes(y = y.3, colour = "y.3")) +
ylab('y') + ggtitle(paste("Matern(nu=", nu,")"))
nu=1.5 # 1 1.5
range=1
my.Matern=function(d1,d2){
Matern(abs(d1-d2), range=range, nu=nu)
}
my.cov=outer (d,d, my.Matern)
gp = mvrnorm(3, mu=rep(0, length(d)), Sigma = my.cov)
my.gp = data.frame(x=d,y=t(gp))
ggplot(my.gp, aes(x=x))+
geom_line(aes(y = y.1, colour = "y.1")) +
geom_line(aes(y = y.2, colour = "y.2")) +
geom_line(aes(y = y.3, colour = "y.3")) +
ylab('y') + ggtitle(paste("Matern(nu=", nu,")"))
grid<- list( x= seq( 0,10,length.out = 200), y= seq(0,10,length.out = 200))
obj1<-matern.image.cov( grid=grid, theta=.5, smoothness=.5, setup=TRUE)
look1<- sim.rf( obj1)
obj2<-matern.image.cov( grid=grid, theta=.5, smoothness=1, setup=TRUE)
look2<- sim.rf( obj2)
obj3<-matern.image.cov( grid=grid, theta=.5, smoothness=2, setup=TRUE)
look3<- sim.rf( obj3)
# take a look at first two
set.panel(1,3)
image.plot( grid$x, grid$y, look1)
title("Matern, nu=0.5")
image.plot( grid$x, grid$y, look2)
title("Matern, nu=1")
image.plot( grid$x, grid$y, look3)
title("Matern, nu=2 ")
dev.off()
library(fields)
data=read.table('data1.txt',header=T)
nlon=length(unique(data[,1]))
nlat=length(unique(data[,2]))
loc=data[,1:2]
y=data[,3]
quilt.plot(data)
varigram=vgram(loc, y, lon.lat=TRUE,N=15)
par(mfrow=c(1,2))
##here obtained is semivarigram,then times 2 to get varigram##
##Plot the varigram cloud
plot(varigram$d,2*varigram$vgram,xlab="distance",ylab="varigram",main="Variogram cloud")
lines(varigram$centers, varigram$stats["mean",], col=4,lwd=3)
bplot.xy(varigram$d, sqrt(2*varigram$vgram),ylab="sqrt(VG)", N=15, outlier=TRUE, main="Boxplots of variogram")
lines(varigram$centers, sqrt(2*varigram$stats["mean",]), col=4,lwd=3)
###directional variogram, fix the latitude.
data1=data[101:150,]
data2=data[201:250,]
data3=data[301:350,]
data4=data[401:450,]
vgram_lat1=vgram(data1[,1:2], data1[,3], lon.lat=TRUE, N=10)
vgram_lat2=vgram(data2[,1:2], data2[,3], lon.lat=TRUE, N=10)
vgram_lat3=vgram(data3[,1:2], data3[,3], lon.lat=TRUE, N=10)
vgram_lat4=vgram(data4[,1:2], data4[,3], lon.lat=TRUE, N=10)
# pdf('lat.pdf',width=14,height=14)
par(mfrow=c(2,2))
bplot.xy(vgram_lat1$d, sqrt(2*vgram_lat1$vgram),ylab="sqrt(VG)", N=10, outlier=TRUE, main="latitude -49.72")
lines(vgram_lat1$centers, sqrt(2*vgram_lat1$stats["mean",]), col=4, lwd=3)
bplot.xy(vgram_lat2$d, sqrt(2*vgram_lat2$vgram),ylab="sqrt(VG)", N=10, outlier=TRUE, main="latitude -9.94")
lines(vgram_lat2$centers, sqrt(2*vgram_lat2$stats["mean",]), col=4, lwd=3)
bplot.xy(vgram_lat3$d, sqrt(2*vgram_lat3$vgram),ylab="sqrt(VG)", N=10, outlier=TRUE, main="latitude 29.83")
lines(vgram_lat3$centers, sqrt(2*vgram_lat3$stats["mean",]), col=4, lwd=3)
bplot.xy(vgram_lat4$d, sqrt(2*vgram_lat4$vgram),ylab="sqrt(VG)", N=10, outlier=TRUE, main="latitude 69.61")
lines(vgram_lat4$centers, sqrt(2*vgram_lat4$stats["mean",]), col=4, lwd=3)
suppressMessages(library( fields))
#  colorado climate data
data(COmonthlyMet)
x<- CO.loc
y<- CO.tmin.MAM.climate
elev<- CO.elev
good<- !is.na( y)
x<- x[good,]
y<- y[good]
elev<- elev[good]
dim(x)
dim(y)
length(y)
NGRID <- 50
# get elevations on a grid (will use these later)
COGrid<- fields.x.to.grid( x, nx=NGRID, ny=NGRID)
COGridPoints<- make.surface.grid( COGrid)
data( RMelevation)
COElevGrid<- interp.surface( RMelevation, COGridPoints )
# take a look at the data
quilt.plot( x, y)
US( add=TRUE)
plot( elev, y)
plot( x[,2], y)
X<- cbind( x, elev)
#
lmObj<- lm( y ~ lon+lat +elev, data=X )
summary( lmObj)
quilt.plot( x, lmObj$residuals)
US( add=TRUE)
fit0E<- Tps( x,y, Z=elev- mean(elev))
# fit a Kriging estimator Matern covariance smoothness =1.0
# range and nugget estimated by maxmimum likelihood
fit1<- spatialProcess( x,y)
# summary of the fit
print( fit1)
# diagnostic plots
set.panel(2,2)
plot( fit1)
set.panel()
surface( fit1)
US( add=TRUE, col="grey", lwd=2)
# take a look at residuals
plot( elev, fit1$residuals)
lmObj<- lm( fit1$residuals ~ elev)
abline( lmObj, col="red", lwd=3)
# with elevations
fit1E<- spatialProcess( x,y, Z = elev)
sur0<- predictSurface( fit1E, nx=NGRID, ny=NGRID, Z= COElevGrid)
sur0<- predictSurface( fit1E, nx=NGRID, ny=NGRID, Z= COElevGrid)
image.plot( sur0, col=terrain.colors(256))
sur0Smooth<- predictSurface( fit1E, nx=NGRID, ny=NGRID, drop.Z= TRUE)
image.plot( sur0Smooth)
# uncertainty 40 draws from posterior distribution
set.seed(123)
# next commmand takes a minute or so
SEout<- sim.spatialProcess( fit1E, xp = COGridPoints,
Z = COElevGrid,
M = 40,
drop.Z = TRUE)
set.panel( 3,3)
image.plot( sur0Smooth,
zlim=c(3.5,14.5), col=tim.colors(256))
contour( sur0Smooth, levels= 9, lwd=3, col="grey", add=TRUE)
par( mar=c(3,3,1,1))
for( k in 1:8){
image( as.surface( COGridPoints, SEout[k,]),
zlim =c(3.5,14.5),col=tim.colors(256), axes=FALSE)
contour( as.surface( COGridPoints, SEout[k,]),
lwd=3, col="grey",level=9, add=TRUE)
title( k, adj=0, cex=2)
}
set.panel()
surSE<- apply( SEout, 2, sd )
image.plot( as.surface( COGridPoints, surSE))
points( x, col="magenta", pch=16)
contour( as.surface( COGridPoints,COElevGrid ),
level= c(2000, 3000), add= TRUE, col="grey30", lwd=3)
US( add=TRUE, col="grey", lwd=2)
suppressWarnings(library(fields))
data( ozone2)
x<- ozone2$lon.lat
y<- ozone2$y[16,]
good<- !is.na( y)
x<- x[good,]
y<- y[good]
# EDA plot of data
set.panel()
quilt.plot( x,y)
US( add= TRUE, lwd=1)
obj1<- Tps( x,y)
# summary of fit
print( obj1)
# four diagnostic plots
set.panel( 2,2)
plot( obj1)
set.panel()
# fitted.surface
surface( obj1)
# Or in three steps
fit1<- predictSurface( obj1)
image.plot( fit1, axes=FALSE)
contour( fit1, add=TRUE)
points( x, cex=.5)
# prediction standard errors
fitSE<- predictSurfaceSE( obj1)
image.plot( fitSE, axes=FALSE)
points( x, col="white")
obj2<- Tps( x,y, m=3)
obj3<- spatialProcess( x,y)
obj4<- spatialProcess( x,y, smoothness=.5)
# estimates of nugget variance
obj1$shat.MLE
obj2$shat.MLE
obj3$sigma.MLE
obj4$sigma.MLE
# compare surface estimates
set.panel(2,2)
zr<- c( 0,200)
par( mar=c(1,1,0,0))
surface( obj1, zlim =zr, axes=FALSE)
points( x, cex=.5)
surface( obj2, zlim =zr, axes=FALSE)
points( x, cex=.5)
surface( obj3, zlim =zr, axes=FALSE)
points( x, cex=.5)
surface( obj4, zlim =zr, axes=FALSE)
points( x, cex=.5)
# reset graphics device
set.panel()
par( mar=c(5,5,2,2))
# curve fitting using different spatial models
data( "WorldBankCO2")
x<- log10( WorldBankCO2[,"GDP.cap"] )
y<-  log10( WorldBankCO2[,"CO2.cap"] )
fields.style()
plot( x,y, pch=16, col="grey",
xlab="log10 GDP",
ylab="log10 CO2")
obj1<- Tps( x,y)
# summary of fitting
print( obj1)
# diagnostic plots of fit -- there are 4
set.panel( 2,2)
plot( obj1)
set.panel()
fields.style()
plot( x,y, pch=16, col="grey",
xlab="log10 GDP",
ylab="log10 CO2")
xgrid<- seq( 2, 4.5, length.out=250)
ghat1<- predict( obj1, xgrid)
lines( xgrid, ghat1, lwd=2)
# compare to Robust spline
obj2<- QTps( x,y)
ghat2<- predict( obj2, xgrid)
lines( xgrid, ghat2, lwd=2, col=2)
# compare to increasing m  use quadratic as base model
obj3<- Tps( x,y,m=3)
ghat3<- predict( obj3, xgrid)
lines( xgrid, ghat3, lwd=2, col=3)
# spatial process model
obj4<- spatialProcess( as.matrix(x), y)
ghat4<- predict( obj4, xgrid)
lines( xgrid, ghat4, lwd=2, col=4)
legend( 3.5,4, lty=1, col=1:4, legend=c("Tps","QTps", "Tps m=3", "SP"))
set.seed(123)
n=100
x=runif(n, -1,1)
z=runif(n, 0, 0.1)
y=x^2+z
plot(x,y)
dev.off()
plot(x,y)
plot(z,y)
plot(x)
plot(y)
cor(x,y)
set.seed(123)
n=1000
x=runif(n, -1,1)
z=runif(n, 0, 0.1)
y=x^2+z
plot(x,y)
cor(x,y)
set.seed(123)
n=100000
x=runif(n, -1,1)
z=runif(n, 0, 0.1)
y=x^2+z
plot(x,y)
cor(x,y)
set.seed(123)
n=1000
x=runif(n, -1,1)
z=runif(n, 0, 0.1)
y=x^2+z
plot(x,y)
cor(x,y)
set.seed(123)
n=10000
x=runif(n, -1,1)
z=runif(n, 0, 0.1)
y=x^2+z
plot(x,y)
cor(x,y)
set.seed(123)
n=10000
x=runif(n, -1,1)
z=runif(n, 0, 0.1)
y=x^2+z
plot(x[1:100],y[1:100])
cor(x,y)
set.seed(123)
n=10000
x=runif(n, -1,1)
z=runif(n, 0, 0.1)
y=x^2+z
plot(x[1:1000],y[1:1000])
cor(x,y)
rm(list=ls())
library(quantreg)
library(devtools)
source("estimation.R")
library(fields)
### ozone data set, day 16
## Quilt plot
data(ozone2)
# plot 16 day of ozone data set
quilt.plot(ozone2$lon.lat, ozone2$y[16,])
US(add=TRUE, col="grey", lwd=2)
good<- !is.na(ozone2$y[16,])
x<- ozone2$lon.lat[good,]
y<- ozone2$y[16,good]
## variogram plots
par(mfrow=c(1,2))
look<-vgram(x,y, N=15, lon.lat=TRUE)
plot(look, pch=19)
## or some boxplot bin summaries
brk<- seq(0, 250,, (25 + 1) ) # will give 25 bins.
boxplotVGram(look, breaks=brk, plot.args=list(type="o"))
plot(look, add=TRUE, breaks=brk, col=4)
dev.off()
fit <- Krig(ChicagoO3$x, ChicagoO3$y, theta=20)
summary(fit) # summary of fit
par(mfrow=c(2,2))
plot(fit) # four diagnostic plots of fit
dev.off()
surface(fit, type="C") # look at the surface
# predict at data
predict(fit)
# predict using 7.5 effective degrees of freedom:
predict(fit, df=7.5)
# predict on a grid (grid chosen here by defaults)
out<- predictSurface(fit)
surface(out, type="C") # option "C" our favorite
# predict at arbitrary points (10,-10) and (20, 15)
xnew<- rbind(c(10, -10), c(20, 15))
predict(fit, xnew)
# standard errors of prediction based on covariance model.
predictSE(fit, xnew)
# surface of standard errors on a default grid
predictSurfaceSE(fit)-> out.p # this takes some time!
surface(out.p, type="C")
points(fit$x)
## Using another stationary covariance.
# smoothness is the shape parameter for the Matern
fit.matern <- Krig(ChicagoO3$x, ChicagoO3$y,
Covariance="Matern", theta=10, smoothness=1.0)
summary( fit.matern)
set.panel(2,2)
plot(fit.matern)
set.panel(1,2)
surface(fit, type="C") # look at the surface
surface(fit.matern, type="C") # look at the surface
dev.off()
## HW01
set.seed(123)
n=10000
x=runif(n, -1,1)
z=runif(n, 0, 0.1)
y=x^2+z
plot(x[1:1000],y[1:1000])
plot(x[1:1000],y[1:1000])
cor(x,y)
n=1000000
x=runif(n, -1,1)
z=runif(n, 0, 0.1)
y=x^2+z
cor(x,y)
library(fields)
### ozone data set, day 16
## Quilt plot
data(ozone2)
# plot 16 day of ozone data set
quilt.plot(ozone2$lon.lat, ozone2$y[16,])
US(add=TRUE, col="grey", lwd=2)
good<- !is.na(ozone2$y[16,])
x<- ozone2$lon.lat[good,]
y<- ozone2$y[16,good]
## variogram plots
par(mfrow=c(1,2))
look<-vgram(x,y, N=15, lon.lat=TRUE)
plot(look, pch=19)
## or some boxplot bin summaries
brk<- seq(0, 250,, (25 + 1) ) # will give 25 bins.
boxplotVGram(look, breaks=brk, plot.args=list(type="o"))
plot(look, add=TRUE, breaks=brk, col=4)
dev.off()
fit <- Krig(ChicagoO3$x, ChicagoO3$y, theta=20)
summary(fit) # summary of fit
summary(fit) # summary of fit
par(mfrow=c(2,2))
plot(fit) # four diagnostic plots of fit
dev.off()
par(mfrow=c(2,2))
plot(fit) # four diagnostic plots of fit
dev.off()
surface(fit, type="C") # look at the surface
# predict at data
predict(fit)
# predict on a grid (grid chosen here by defaults)
out<- predictSurface(fit)
surface(out, type="C") # option "C" our favorite
# predict at arbitrary points (10,-10) and (20, 15)
xnew<- rbind(c(10, -10), c(20, 15))
predict(fit, xnew)
# standard errors of prediction based on covariance model.
predictSE(fit, xnew)
# surface of standard errors on a default grid
predictSurfaceSE(fit)-> out.p # this takes some time!
surface(out.p, type="C")
points(fit$x)
## Using another stationary covariance.
# smoothness is the shape parameter for the Matern
fit.matern <- Krig(ChicagoO3$x, ChicagoO3$y,
Covariance="Matern", theta=10, smoothness=1.0)
summary( fit.matern)
set.panel(2,2)
plot(fit.matern)
set.panel(1,2)
surface(fit, type="C") # look at the surface
surface(fit.matern, type="C") # look at the surface
