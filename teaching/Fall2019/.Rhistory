library(boot)     #for coal data
library(boot)     #for coal data
data(coal)
year <- floor(coal)
y <- table(year)
plot(y)  #a time plot
y <- floor(coal[[1]])  # convert data.frame to numeric
y <- tabulate(y)
y <- y[1851:length(y)]   # starting from year 1851
n <- length(y)    #length of the data
m <- 1000         #length of the chain
mu <- lambda <- k <- numeric(m)
L <- numeric(n)
k[1] <- sample(1:n, 1)
mu[1] <- 1
lambda[1] <- 1
b1 <- 1
b2 <- 1
for (i in 2:m) {
kt <- k[i-1]
#generate mu
r <- .5 + sum(y[1:kt])
mu[i] <- rgamma(1, shape = r, rate = kt + b1)
#generate lambda
if (kt + 1 > n) r <- .5 + sum(y) else
r <- .5 + sum(y[(kt+1):n])
lambda[i] <- rgamma(1, shape = r, rate = n - kt + b2)
#generate b1 and b2
b1 <- rgamma(1, shape = .5, rate = mu[i]+1)
b2 <- rgamma(1, shape = .5, rate = lambda[i]+1)
for (j in 1:n) {
L[j] <- exp((lambda[i] - mu[i]) * j) *
(mu[i] / lambda[i])^sum(y[1:j])
}
L <- L / sum(L)
#generate k from discrete distribution L on 1:n
k[i] <- sample(1:n, prob=L, size=1)
}
b <- 201
j <- k[b:m]
print(mean(k[b:m]))
print(mean(lambda[b:m]))
print(mean(mu[b:m]))
mean(j)
print(mean(k[b:m]))
print(mean(lambda[b:m]))
print(mean(mu[b:m]))
.Machine
factorial(200)
factorial(200)/factorial(198)
n <- 400
factorial(n)
(gamma((n-1)/2) / (sqrt(pi) * gamma((n-2)/2)))
exp(lgamma((n-1)/2) - lgamma((n-2)/2)) / sqrt(pi)
(.2-.1)==.1
(0.3-0.1)==0.2
0.2-(0.3-0.1)
system.time({
for (i in 1:1000) {
a <- rep(0, 24)
a0 <- pi / 6
a2 <- a0 * a0
a[1] <- -a0^3 / 6
for (i in 2:24)
a[i] <- - a2 * a[i-1] / ((2*i+1)*(2*i))
a0 + sum(a)}
})
system.time({
for (i in 1:1000) {
K <- 2 * (0:24) + 1
i <- rep(c(1, -1), length=25)
sum(i * (pi/6)^K / factorial(K))}
})
f <- function(y, a, n) {
a^2 + y^2 + 2*a*y/(n-1) - (n-2)
}
a <- 0.5
n <- 20
b0 <- 0
b1 <- 5*n
it <- 0
eps <- .Machine$double.eps^0.25
r <- seq(b0, b1, length=3)
y <- c(f(r[1], a, n), f(r[2], a, n), f(r[3], a, n))
if (y[1] * y[3] > 0)
stop("f does not have opposite sign at endpoints")
while(it < 1000 && abs(y[2]) > eps) {
it <- it + 1
if (y[1]*y[2] < 0) {
r[3] <- r[2]
y[3] <- y[2]
} else {
r[1] <- r[2]
y[1] <- y[2]
}
r[2] <- (r[1] + r[3]) / 2
y[2] <- f(r[2], a=a, n=n)
print(c(r[1], y[1], y[3]-y[2]))
}
it
a <- 0.5
n <- 20
out <- uniroot(function(y) {
a^2 + y^2 + 2*a*y/(n-1) - (n-2) },
lower = 0, upper = n*5)
unlist(out)
uniroot(function(y) {a^2 + y^2 + 2*a*y/(n-1) - (n-2)},
interval = c(-n*5, 0))$root
f <- function(y, N, r, rho) {
(cosh(y) - rho * r)^(1 - N)
}
integrate(f, lower=0, upper=Inf,
rel.tol=.Machine$double.eps^0.25,
N=10, r=0.5, rho=0.2)
ro <- seq(-.99, .99, .01)
v <- rep(0, length(ro))
for (i in 1:length(ro)) {
v[i] <- integrate(f, lower=0, upper=Inf,
rel.tol=.Machine$double.eps^0.25,
N=10, r=0.5, rho=ro[i])$value
}
plot(ro, v, type="l", xlab=expression(rho),
ylab="Integral Value (n=10, r=0.5)")
.dcorr <- function(r, N, rho=0) {
# compute the density function of sample correlation
if (abs(r) > 1 || abs(rho) > 1) return (0)
if (N < 4) return (NA)
if (isTRUE(all.equal(rho, 0.0))) {
a <- exp(lgamma((N - 1)/2) - lgamma((N - 2)/2)) /
sqrt(pi)
return (a * (1 - r^2)^((N - 4)/2))
}
# if rho not 0, need to integrate
f <- function(w, R, N, rho)
(cosh(w) - rho * R)^(1 - N)
#need to insert some error checking here
i <- integrate(f, lower=0, upper=Inf,
R=r, N=N, rho=rho)$value
c1 <- (N - 2) * (1 - rho^2)^((N - 1)/2)
c2 <- (1 - r^2)^((N - 4) / 2) / pi
return(c1 * c2 * i)
}
r <- as.matrix(seq(-1, 1, .01))
d1 <- apply(r, 1, .dcorr, N=10, rho=.0)
d2 <- apply(r, 1, .dcorr, N=10, rho=.5)
d3 <- apply(r, 1, .dcorr, N=10, rho=-.5)
plot(r, d2, type="l", lty=2, lwd=2, ylab="density")
lines(r, d1, lwd=2)
lines(r, d3, lty=4, lwd=2)
legend("top", inset=.02,
c("rho = 0", "rho = 0.5", "rho = -0.5"), lty=c(1,2,4), lwd=2)
plot(r, d2, type="l", lty=2, lwd=2, ylab="density")
lines(r, d1, lwd=2)
lines(r, d3, lty=4, lwd=2)
y <- c(0.04304550, 0.50263474)
y <- c(0.04304550, 0.50263474)
mlogL <- function(theta=1) {
#minus log-likelihood of exp. density, rate 1/theta
return( - (length(y) * log(theta) - theta * sum(y)))
}
library(stats4)
fit <- mle(mlogL)
summary(fit)
1/mean(y)
## ggplot version
library(ggplot2)
df <- data.frame(lengths = factor(r$lengths))
# Datasets showcase
help(density)
# The Old Faithful geyser data
help(faithful)
d <- density(faithful$eruptions, bw = "sj")
d
plot(d, main="Eruption time in minutes")
# Data list for all available packages
data()
# rolls n fair dice and returns the sum
sumdice <- function(n) {
k <- sample(1:6, size=n, replace=TRUE)
return(sum(k))
}
sumdice(2)
a <- sumdice(10000)
a / 10000
# An alternative
sumdice <- function(n)
sum(sample(1:6, size=n, replace=TRUE))
# Add an extra parameter of dice side number
sumdice <- function(n, sides = 6) {
if (sides < 1) return (0)
k <- sample(1:sides, size=n, replace=TRUE)
return(sum(k))
}
sumdice(5) # default 6 sides
sumdice(n=5, sides=4) # 4 sides
help("iris")
class(iris)
dim(iris)
head(iris)
names(iris)
table(iris$Species)
summary(iris$Species)
w <- iris[[2]] #Column Sepal.Width
mean(w)
r
## ggplot version
library(ggplot2)
df <- data.frame(lengths = factor(r$lengths))
?rle
r <- rle(x)
n <- 1000
x <- rbinom(n, size = 1, prob = .5)
table(x)
head(x, 30)
r <- rle(x)
str(r)
## ggplot version
library(ggplot2)
df <- data.frame(lengths = factor(r$lengths))
ggplot(df, aes(lengths)) + geom_bar()
ggplot(data = iris, aes(x = Sepal.Length, y = Sepal.Width)) +
geom_point()
ggplot(iris, aes(Sepal.Length, Sepal.Width,
color = Species, shape = Species)) + geom_point(size = 2)
ggplot(iris, aes(Species, Sepal.Length)) + geom_boxplot()
ggplot(iris, aes(Species, Sepal.Length)) + geom_violin()
ggplot(iris, aes(Species, Sepal.Length)) +
geom_boxplot() + coord_flip()
ggplot(iris, aes(Species, Sepal.Length)) +
geom_violin() + coord_flip()
ggplot(mpg, aes(displ, hwy)) +
geom_point() +
facet_wrap(~ class)
# copy "FOREARM.DAT" into working directory
forearm <- scan(file = "FOREARM.DAT") #a vector
rm(list = ls())
help("iris")
class(iris)
dim(iris)
head(iris)
names(iris)
table(iris$Species)
summary(iris$Species)
w <- iris[[2]] #Column Sepal.Width
mean(w)
# equivalent
w = iris$Sepal.Width
w = iris[,2] # more general, can select multiple elements
library(ggplot2)
ggplot(data = iris, aes(x = Sepal.Length, y = Sepal.Width)) +
geom_point()
ggplot(iris, aes(Sepal.Length, Sepal.Width,
color = Species, shape = Species)) + geom_point(size = 2)
ggplot(iris, aes(Species, Sepal.Length)) + geom_boxplot()
ggplot(iris, aes(Species, Sepal.Length)) + geom_violin()
ggplot(iris, aes(Species, Sepal.Length)) +
geom_boxplot() + coord_flip()
ggplot(iris, aes(Species, Sepal.Length)) +
geom_violin() + coord_flip()
?geom_violin
dev.off()
rm(list = ls())
# Calculator
pi
exp(1)
log(2)
sqrt(pi)
#density of standard normal at value 2
1/sqrt(2*pi) * exp(-2)
dnorm(2)
?dnorm
# Basic graphics
plot(cars, xlab="Speed", ylab="Distance to Stop",
main="Stopping Distance for Cars in 1920")
cars
# Powerful seq function
seq(0, 3, 0.5)
?t
t
class(t)
g
x = 1:6
x
6:1
sample(x) #permutation of all elements of x
k=3
sample(x, size=k) #permutation of k elements of x
set.seed(123)
sample(x)
sample(x, size=k)
set.seed(123)
sample(x)
sample(x, size=k)
sample(x)
sample(x)
# rolls n fair dice and returns the sum
sumdice <- function(n) {
k <- sample(1:6, size=n, replace=TRUE)
return(sum(k))
}
sumdice(2)
a <- sumdice(10000)
a / 10000
help("iris")
class(iris)
class(iris)
dim(iris)
head(iris)
head(iris)
names(iris)
head(iris)
names(iris)
table(iris$Species)
summary(iris$Species)
library(ggplot2)
library(ggplot2)
ggplot(data = iris, aes(x = Sepal.Length, y = Sepal.Width)) +
geom_point()
ggplot(iris, aes(Sepal.Length, Sepal.Width,
color = Species, shape = Species)) + geom_point(size = 2)
ggplot(iris, aes(Species, Sepal.Length)) + geom_boxplot()
ggplot(iris, aes(Species, Sepal.Length)) + geom_violin()
ggplot(iris, aes(Species, Sepal.Length)) +
geom_boxplot() + coord_flip()
ggplot(iris, aes(Species, Sepal.Length)) +
geom_violin() + coord_flip()
#########################
# Arrays
# An array is a multiply subscripted collection of a single type of data.
x <- 1:24 # vector
dim(x) <- length(x) # 1 dimensional array
matrix(1:24, nrow=4, ncol=6) # 4 by 6 matrix
n <- 1000
k <- 0      #counter for accepted
j <- 0      #iterations
y <- numeric(n)
while (k < n) {
u <- runif(1)
j <- j + 1
x <- runif(1)  #random variate from g
if (x * (1-x) > u) {
#we accept x
k <- k + 1
y[k] <- x
}
}
j
# change c to be 1.5
n <- 1000
k <- 0      #counter for accepted
j <- 0      #iterations
y <- numeric(n)
while (k < n) {
u <- runif(1)
j <- j + 1
x <- runif(1)  #random variate from g
if (4*x * (1-x) > u) {
#we accept x
k <- k + 1
y[k] <- x
}
}
j
#compare empirical and theoretical percentiles
p <- seq(.1, .9, .1)
Qhat <- quantile(y, p)   #quantiles of sample
Q <- qbeta(p, 2, 2)      #theoretical quantiles
# se <- sqrt(p * (1-p) / (n * dbeta(Q, 2, 2)^2)) #see Ch. 2
round(rbind(Qhat, Q), 3)
# se <- sqrt(p * (1-p) / (n * dbeta(Q, 2, 2)^2)) #see Ch. 2
round(rbind(Qhat, Q), 3)
n <- 1000
u <- runif(n)
x <- u^(1/3)
hist(x, prob = TRUE, main = expression(f(x)==3*x^2)) #density histogram of sample
y <- seq(0, 1, .01)
lines(y, 3*y^2)    #density curve f(x)
n <- 100000
p <- 0.4
u <- runif(n)
x <- as.integer(u > 0.6)   #(u > 0.6) is a logical vector
mean(x) # p=0.4
var(x)  # p*(1-p)=0.24
