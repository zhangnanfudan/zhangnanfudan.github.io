p[j] <- ttest$p.value
}
p.hat <- mean(p < alpha)
se.hat <- sqrt(p.hat * (1 - p.hat) / m)
print(c(p.hat, se.hat))
n <- c(10, 20, 30, 50, 100, 500) #sample sizes
cv <- qnorm(.975, 0, sqrt(6/n))  #crit. values for each n
sk <- function(x) {
#computes the sample skewness coeff.
xbar <- mean(x)
m3 <- mean((x - xbar)^3)
m2 <- mean((x - xbar)^2)
return( m3 / m2^1.5 )
}
p.reject <- numeric(length(n)) #to store sim. results
m <- 10000                     #num. repl. each sim.
for (i in 1:length(n)) {
sktests <- numeric(m)       #test decisions
for (j in 1:m) {
x <- rnorm(n[i])
#test decision is 1 (reject) or 0
sktests[j] <- as.integer(abs(sk(x)) >= cv[i] )
}
p.reject[i] <- mean(sktests) #proportion rejected
}
p.asym = p.reject
plot(p.asym, ylim=c(0,.1), type='o', lwd=2)
abline(h=0.05, lty=2, lwd=2, col='red')
plot(n, p.asym, ylim=c(0,.1), type='o', lwd=2)
abline(h=0.05, lty=2, lwd=2, col='red')
# Use an exact variance to calculate the critical values
cv <- qnorm(.975, 0, sqrt(6*(n-2) / ((n+1)*(n+3))))
p.reject <- numeric(length(n)) #to store sim. results
m <- 10000                     #num. repl. each sim.
for (i in 1:length(n)) {
sktests <- numeric(m)       #test decisions
for (j in 1:m) {
x <- rnorm(n[i])
#test decision is 1 (reject) or 0
sktests[j] <- as.integer(abs(sk(x)) >= cv[i] )
}
p.reject[i] <- mean(sktests) #proportion rejected
}
p.reject
lines(p.reject, lwd=2, type='b', col='blue')
lines(n, p.reject, lwd=2, type='b', col='blue')
plot(p.asym, ylim=c(0,.1), type='o', lwd=2)
abline(h=0.05, lty=2, lwd=2, col='red')
# Use an exact variance to calculate the critical values
cv <- qnorm(.975, 0, sqrt(6*(n-2) / ((n+1)*(n+3))))
p.reject <- numeric(length(n)) #to store sim. results
m <- 10000                     #num. repl. each sim.
for (i in 1:length(n)) {
sktests <- numeric(m)       #test decisions
for (j in 1:m) {
x <- rnorm(n[i])
#test decision is 1 (reject) or 0
sktests[j] <- as.integer(abs(sk(x)) >= cv[i] )
}
p.reject[i] <- mean(sktests) #proportion rejected
}
p.reject
lines(p.reject, lwd=2, type='b', col='blue')
n <- 20
m <- 1000
mu0 <- 500
sigma <- 100
mu <- c(seq(450, 650, 10))  #alternatives
M <- length(mu)
power <- numeric(M)
for (i in 1:M) {
mu1 <- mu[i]
pvalues <- replicate(m, expr = {
#simulate under alternative mu1
x <- rnorm(n, mean = mu1, sd = sigma)
ttest <- t.test(x,
alternative = "two.sided", mu = mu0)
# try "two.sided" and "less"
ttest$p.value  } )
power[i] <- mean(pvalues <= .05)
}
#par(ask = TRUE)
library(Hmisc)  #for errbar
plot(mu, power)
abline(v = mu0, lty = 1)
abline(h = .05, lty = 1)
#add standard errors
se <- sqrt(power * (1-power) / m)
errbar(mu, power, yplus = power+se, yminus = power-se,
xlab = bquote(theta))
lines(mu, power, lty=3)
for (i in 1:M) {
mu1 <- mu[i]
pvalues <- replicate(m, expr = {
#simulate under alternative mu1
x <- rnorm(n, mean = mu1, sd = sigma)
ttest <- t.test(x,
alternative = "greater", mu = mu0)
# try "two.sided" and "less"
ttest$p.value  } )
power[i] <- mean(pvalues <= .05)
}
#par(ask = TRUE)
library(Hmisc)  #for errbar
plot(mu, power)
abline(v = mu0, lty = 1)
abline(h = .05, lty = 1)
#add standard errors
se <- sqrt(power * (1-power) / m)
errbar(mu, power, yplus = power+se, yminus = power-se,
xlab = bquote(theta))
lines(mu, power, lty=3)
abline(v = mu0, lty = 1)
abline(h = .05, lty = 1)
abline(h = .05, lty = 1)
detach(package:Hmisc)
alpha <- .1
n <- 30
m <- 2500
epsilon <- c(seq(0, .15, .01), seq(.15, 1, .05))
N <- length(epsilon)
pwr <- numeric(N)
#critical value for the skewness test
cv <- qnorm(1-alpha/2, 0, sqrt(6*(n-2) / ((n+1)*(n+3))))
for (j in 1:N) {           #for each epsilon
e <- epsilon[j]
sktests <- numeric(m)
for (i in 1:m) {       #for each replicate
sigma <- sample(c(1, 10), replace = TRUE,
size = n, prob = c(1-e, e))
x <- rnorm(n, 0, sigma)
sktests[i] <- as.integer(abs(sk(x)) >= cv)
}
pwr[j] <- mean(sktests)
}
#plot power vs epsilon
plot(epsilon, pwr, type = "b",
xlab = bquote(epsilon), ylim = c(0,1))
abline(h = .1, lty = 3)
se <- sqrt(pwr * (1-pwr) / m)  #add standard errors
lines(epsilon, pwr+se, lty = 3, lwd=2, col=2)
lines(epsilon, pwr-se, lty = 3, lwd=2, col=2)
# initialize input and output
library(energy)
alpha <- .1
n <- 30
m <- 100        #try small m for a trial run
test1 <- test2 <- test3 <- numeric(m)
#critical value for the skewness test
cv <- qnorm(1-alpha/2, 0, sqrt(6*(n-2) / ((n+1)*(n+3))))
sim <- matrix(0, 11, 4)
# estimate power
for (i in 0:10) {
epsilon <- i * .1
for (j in 1:m) {
e <- epsilon
sigma <- sample(c(1, 10), replace = TRUE,
size = n, prob = c(1-e, e))
x <- rnorm(n, 0, sigma)
test1[j] <- as.integer(abs(sk(x)) >= cv)
test2[j] <- as.integer(
shapiro.test(x)$p.value <= alpha)
test3[j] <- as.integer(
mvnorm.etest(x, R=200)$p.value <= alpha)
}
print(c(epsilon, mean(test1), mean(test2), mean(test3)))
sim[i+1, ] <- c(epsilon, mean(test1), mean(test2), mean(test3))
}
detach(package:energy)
# plot the empirical estimates of power
plot(sim[,1], sim[,2], ylim = c(0, 1), type = "l",
xlab = bquote(epsilon), ylab = "power")
lines(sim[,1], sim[,3], lty = 2, col=2)
lines(sim[,1], sim[,4], lty = 4, col=3)
abline(h = alpha, lty = 3)
legend("topright", 1, c("skewness", "S-W", "energy"),
lty = c(1,2,4), col=1:3, inset = .02)
set.seed(522)
n <- 20
K <- n/2 - 1
m <- 10000
mse <- matrix(0, n/2, 6)
trimmed.mse <- function(n, m, k, p) {
#MC est of mse for k-level trimmed mean of
#contaminated normal pN(0,1) + (1-p)N(0,100)
tmean <- numeric(m)
for (i in 1:m) {
sigma <- sample(c(1, 10), size = n,
replace = TRUE, prob = c(p, 1-p))
x <- sort(rnorm(n, 0, sigma))
tmean[i] <- sum(x[(k+1):(n-k)]) / (n-2*k)
}
mse.est <- mean(tmean^2)
se.mse <- sqrt(mean((tmean-mean(tmean))^2)) / sqrt(m)
return(c(mse.est, se.mse))
}
for (k in 0:K) {
mse[k+1, 1:2] <- trimmed.mse(n=n, m=m, k=k, p=1.0)
mse[k+1, 3:4] <- trimmed.mse(n=n, m=m, k=k, p=.95)
mse[k+1, 5:6] <- trimmed.mse(n=n, m=m, k=k, p=.9)
}
mse=data.frame(mse) # see errata
colnames(mse) = c('nMSE,p=1','nSE,p=1','nMSE,p=.95','nSE,p=.95','nMSE,p=.9','nSE,p=.9')
round(20*mse,digits = 3)
# balance between contamination level (p) and robustification level (k)
plot(mse[,5], type='o', col=4, lwd=2, ylim=c(0,.6),
xlab='Trimming level k', ylab='Mean Square Error',
main='Contamination v.s. Robustification')
lines(mse[,3], type='o',col=3,lwd=2)
lines(mse[,1], type='o',col=2,lwd=2)
legend("topright", legend = c("p=1","p=0.95","p=0.9"),
lwd=2, col = 2:4)
set.seed(522)
n <- 20
K <- n/2 - 1
m <- 10000
mse <- matrix(0, n/2, 6)
trimmed.mse <- function(n, m, k, p) {
#MC est of mse for k-level trimmed mean of
#contaminated normal pN(0,1) + (1-p)N(0,100)
tmean <- numeric(m)
for (i in 1:m) {
sigma <- sample(c(1, 10), size = n,
replace = TRUE, prob = c(p, 1-p))
x <- sort(rnorm(n, 0, sigma))
tmean[i] <- sum(x[(k+1):(n-k)]) / (n-2*k)
}
mse.est <- mean(tmean^2)
se.mse <- sqrt(mean((tmean-mean(tmean))^2)) / sqrt(m)
return(c(mse.est, se.mse))
}
hist(x)
sigma <- sample(c(1, 10), size = n,
replace = TRUE, prob = c(p, 1-p))
x <- sort(rnorm(n, 0, sigma))
sigma <- sample(c(1, 10), size = n,
replace = TRUE, prob = c(p, 1-p))
p=.95
sigma <- sample(c(1, 10), size = n,
replace = TRUE, prob = c(p, 1-p))
sigma <- sample(c(1, 10), size = n,
replace = TRUE, prob = c(p, 1-p))
x <- sort(rnorm(n, 0, sigma))
hist(x)
n=200
sigma <- sample(c(1, 10), size = n,
replace = TRUE, prob = c(p, 1-p))
x <- sort(rnorm(n, 0, sigma))
hist(x)
trimmed.mse <- function(n, m, k, p) {
#MC est of mse for k-level trimmed mean of
#contaminated normal pN(0,1) + (1-p)N(0,100)
tmean <- numeric(m)
for (i in 1:m) {
sigma <- sample(c(1, 10), size = n,
replace = TRUE, prob = c(p, 1-p))
x <- sort(rnorm(n, 0, sigma))
tmean[i] <- sum(x[(k+1):(n-k)]) / (n-2*k)
}
mse.est <- mean(tmean^2)
se.mse <- sqrt(mean((tmean-mean(tmean))^2)) / sqrt(m)
return(c(mse.est, se.mse))
}
for (k in 0:K) {
mse[k+1, 1:2] <- trimmed.mse(n=n, m=m, k=k, p=1.0)
mse[k+1, 3:4] <- trimmed.mse(n=n, m=m, k=k, p=.95)
mse[k+1, 5:6] <- trimmed.mse(n=n, m=m, k=k, p=.9)
}
mse=data.frame(mse) # see errata
colnames(mse) = c('nMSE,p=1','nSE,p=1','nMSE,p=.95','nSE,p=.95','nMSE,p=.9','nSE,p=.9')
round(20*mse,digits = 3)
# balance between contamination level (p) and robustification level (k)
plot(mse[,5], type='o', col=4, lwd=2, ylim=c(0,.6),
xlab='Trimming level k', ylab='Mean Square Error',
main='Contamination v.s. Robustification')
lines(mse[,3], type='o',col=3,lwd=2)
lines(mse[,1], type='o',col=2,lwd=2)
legend("topright", legend = c("p=1","p=0.95","p=0.9"),
lwd=2, col = 2:4)
set.seed(522)
n <- 20
K <- n/2 - 1
m <- 10000
mse <- matrix(0, n/2, 6)
trimmed.mse <- function(n, m, k, p) {
#MC est of mse for k-level trimmed mean of
#contaminated normal pN(0,1) + (1-p)N(0,100)
tmean <- numeric(m)
for (i in 1:m) {
sigma <- sample(c(1, 10), size = n,
replace = TRUE, prob = c(p, 1-p))
x <- sort(rnorm(n, 0, sigma))
tmean[i] <- sum(x[(k+1):(n-k)]) / (n-2*k)
}
mse.est <- mean(tmean^2)
se.mse <- sqrt(mean((tmean-mean(tmean))^2)) / sqrt(m)
return(c(mse.est, se.mse))
}
for (k in 0:K) {
mse[k+1, 1:2] <- trimmed.mse(n=n, m=m, k=k, p=1.0)
mse[k+1, 3:4] <- trimmed.mse(n=n, m=m, k=k, p=.95)
mse[k+1, 5:6] <- trimmed.mse(n=n, m=m, k=k, p=.9)
}
mse=data.frame(mse) # see errata
colnames(mse) = c('nMSE,p=1','nSE,p=1','nMSE,p=.95','nSE,p=.95','nMSE,p=.9','nSE,p=.9')
round(20*mse,digits = 3)
# balance between contamination level (p) and robustification level (k)
plot(mse[,5], type='o', col=4, lwd=2, ylim=c(0,.6),
xlab='Trimming level k', ylab='Mean Square Error',
main='Contamination v.s. Robustification')
lines(mse[,3], type='o',col=3,lwd=2)
lines(mse[,1], type='o',col=2,lwd=2)
legend("topright", legend = c("p=1","p=0.95","p=0.9"),
lwd=2, col = 2:4)
set.seed(522)
n <- 20
K <- n/2 - 1
m <- 10000
mse <- matrix(0, n/2, 6)
trimmed.mse <- function(n, m, k, p) {
#MC est of mse for k-level trimmed mean of
#contaminated normal pN(0,1) + (1-p)N(0,100)
tmean <- numeric(m)
for (i in 1:m) {
sigma <- sample(c(1, 10), size = n,
replace = TRUE, prob = c(p, 1-p))
x <- sort(rnorm(n, 0, sigma))
tmean[i] <- sum(x[(k+1):(n-k)]) / (n-2*k)
}
mse.est <- mean(tmean^2)
se.mse <- sqrt(mean((tmean-mean(tmean))^2)) / sqrt(m)
return(c(mse.est, se.mse))
}
for (k in 0:K) {
mse[k+1, 1:2] <- trimmed.mse(n=n, m=m, k=k, p=1.0)
mse[k+1, 3:4] <- trimmed.mse(n=n, m=m, k=k, p=.95)
mse[k+1, 5:6] <- trimmed.mse(n=n, m=m, k=k, p=.9)
}
mse=data.frame(mse) # see errata
colnames(mse) = c('nMSE,p=1','nSE,p=1','nMSE,p=.95','nSE,p=.95','nMSE,p=.9','nSE,p=.9')
round(20*mse,digits = 3)
# balance between contamination level (p) and robustification level (k)
plot(mse[,5], type='o', col=4, lwd=2, ylim=c(0,.6),
xlab='Trimming level k', ylab='Mean Square Error',
main='Contamination v.s. Robustification')
lines(mse[,3], type='o',col=3,lwd=2)
lines(mse[,1], type='o',col=2,lwd=2)
legend("topright", legend = c("p=1","p=0.95","p=0.9"),
lwd=2, col = 2:4)
### Example 6.4 (Confidence interval for variance)
n <- 20
alpha <- .05
x <- rnorm(n, mean=0, sd=2)
UCL <- (n-1) * var(x) / qchisq(alpha, df=n-1)
UCL
### Example 6.5 (MC estimate of confidence level)
#set.seed(123)
n <- 20
alpha <- .05
UCL <- replicate(1000, expr = {
x <- rnorm(n, mean = 0, sd = 2)
(n-1) * var(x) / qchisq(alpha, df = n-1)
} )
#count the number of intervals that contain sigma^2=4
sum(UCL > 4)
#or compute the mean to get the confidence level
a = mean(UCL > 4)
a
### Example 6.5 (MC estimate of confidence level)
#set.seed(123)
n <- 20
alpha <- .05
UCL <- replicate(1000, expr = {
x <- rnorm(n, mean = 0, sd = 2)
(n-1) * var(x) / qchisq(alpha, df = n-1)
} )
#count the number of intervals that contain sigma^2=4
sum(UCL > 4)
#or compute the mean to get the confidence level
a = mean(UCL > 4)
a
# standard error
sqrt(a*(1-a)/1000)
### Example 6.6 (Empirical confidence level)
# non-Gaussian case, chisquare(2)
n <- 20
alpha <- .05
UCL <- replicate(1000, expr = {
x <- rchisq(n, df = 2)
(n-1) * var(x) / qchisq(alpha, df = n-1)
} )
sum(UCL > 4)
a = mean(UCL > 4)
a
# standard error
sqrt(a*(1-a)/1000)
### Example 6.7 (Empirical Type I error rate)
# t-test for mean with unknown sigma
n <- 20
alpha <- .05
mu0 <- 500
sigma <- 100
m <- 10000          #number of replicates
p <- numeric(m)     #storage for p-values
for (j in 1:m) {
x <- rnorm(n, mu0, sigma)
ttest <- t.test(x, alternative = "greater", mu = mu0)
p[j] <- ttest$p.value
}
p.hat <- mean(p < alpha)
se.hat <- sqrt(p.hat * (1 - p.hat) / m)
print(c(p.hat, se.hat))
n <- c(10, 20, 30, 50, 100, 500) #sample sizes
cv <- qnorm(.975, 0, sqrt(6/n))  #crit. values for each n
sk <- function(x) {
#computes the sample skewness coeff.
xbar <- mean(x)
m3 <- mean((x - xbar)^3)
m2 <- mean((x - xbar)^2)
return( m3 / m2^1.5 )
}
p.reject <- numeric(length(n)) #to store sim. results
m <- 10000                     #num. repl. each sim.
for (i in 1:length(n)) {
sktests <- numeric(m)       #test decisions
for (j in 1:m) {
x <- rnorm(n[i])
#test decision is 1 (reject) or 0
sktests[j] <- as.integer(abs(sk(x)) >= cv[i] )
}
p.reject[i] <- mean(sktests) #proportion rejected
}
p.asym = p.reject
plot(p.asym, ylim=c(0,.1), type='o', lwd=2)
abline(h=0.05, lty=2, lwd=2, col='red')
# Use an exact variance to calculate the critical values
cv <- qnorm(.975, 0, sqrt(6*(n-2) / ((n+1)*(n+3))))
p.reject <- numeric(length(n)) #to store sim. results
m <- 10000                     #num. repl. each sim.
for (i in 1:length(n)) {
sktests <- numeric(m)       #test decisions
for (j in 1:m) {
x <- rnorm(n[i])
#test decision is 1 (reject) or 0
sktests[j] <- as.integer(abs(sk(x)) >= cv[i] )
}
p.reject[i] <- mean(sktests) #proportion rejected
}
p.reject
lines(p.reject, lwd=2, type='b', col='blue')
n <- 20
m <- 1000
mu0 <- 500
sigma <- 100
mu <- c(seq(450, 650, 10))  #alternatives
M <- length(mu)
power <- numeric(M)
for (i in 1:M) {
mu1 <- mu[i]
pvalues <- replicate(m, expr = {
#simulate under alternative mu1
x <- rnorm(n, mean = mu1, sd = sigma)
ttest <- t.test(x,
alternative = "greater", mu = mu0)
# try "two.sided" and "less"
ttest$p.value  } )
power[i] <- mean(pvalues <= .05)
}
#par(ask = TRUE)
library(Hmisc)  #for errbar
plot(mu, power)
abline(v = mu0, lty = 1)
abline(h = .05, lty = 1)
#add standard errors
se <- sqrt(power * (1-power) / m)
errbar(mu, power, yplus = power+se, yminus = power-se,
xlab = bquote(theta))
abline(v = mu0, lty = 1)
abline(h = .05, lty = 1)
lines(mu, power, lty=3)
for (i in 1:M) {
mu1 <- mu[i]
pvalues <- replicate(m, expr = {
#simulate under alternative mu1
x <- rnorm(n, mean = mu1, sd = sigma)
ttest <- t.test(x,
alternative = "less", mu = mu0)
# try "two.sided" and "less"
ttest$p.value  } )
power[i] <- mean(pvalues <= .05)
}
#par(ask = TRUE)
library(Hmisc)  #for errbar
plot(mu, power)
abline(v = mu0, lty = 1)
abline(h = .05, lty = 1)
for (i in 1:M) {
mu1 <- mu[i]
pvalues <- replicate(m, expr = {
#simulate under alternative mu1
x <- rnorm(n, mean = mu1, sd = sigma)
ttest <- t.test(x,
alternative = "two.sided", mu = mu0)
# try "two.sided" and "less"
ttest$p.value  } )
power[i] <- mean(pvalues <= .05)
}
#par(ask = TRUE)
library(Hmisc)  #for errbar
plot(mu, power)
abline(v = mu0, lty = 1)
abline(h = .05, lty = 1)
